import './polyfills/classlist';
import FullscreenButton from './ui/btn-fullscreen';
import ImgSelect from './ui/image-select';
import InactivityMonitor from './ui/inactivity-monitor';
import ImgDimWarn from './ui/img-dimension-warning';
import MainMenu from './ui/menu';
import Renderer from './renderer';
import Config from './config';

console.info(Config);

// some constants
const imageLoadingClass = 'loading-image';
const canvas = document.getElementById('main-canvas');

// set up ui components
const fullscreen = new FullscreenButton();
const imgSelect = new ImgSelect();
const inactivityMonitor = new InactivityMonitor();
const imgDimWarn = new ImgDimWarn();
const renderer = new Renderer(canvas);
const menu = new MainMenu(renderer.getClock());

if (window.localStorage) {
  const configJson = window.localStorage.getItem('savedConfig');
  if (configJson !== null) {
    const config = JSON.parse(configJson);
    menu.applyConfig(config);
    menu.submit();
  }
}

const adjustCanvasSize = () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  renderer.resize(window.innerWidth, window.innerHeight);
};
window.addEventListener('resize', adjustCanvasSize);
adjustCanvasSize();

let isInitialPageLoad = true;
const srcImage = document.createElement('img');
srcImage.crossOrigin = 'Anonymous'; // http://stackoverflow.com/a/27840082/1468532
srcImage.src = 'tron.jpg';
srcImage.onload = () => {
  if (isInitialPageLoad) {
    isInitialPageLoad = false;
    renderer.getState().setDefaultDomImage(srcImage);
    const particleCounts = {};
    if (!menu.submittedConfig.xParticlesCount) {
      particleCounts.xParticlesCount = srcImage.naturalWidth;
    }
    if (!menu.submittedConfig.yParticlesCount) {
      particleCounts.yParticlesCount = srcImage.naturalHeight;
    }
    // This is hacky, but we want to get the default particle count from the default image,
    // so what else can we do?
    menu.defaultConfig = Object.assign(menu.defaultConfig, particleCounts);
    menu.applyConfig(Object.assign(menu.submittedConfig, particleCounts));
    menu.submit();
    document.documentElement.classList.remove(imageLoadingClass);
  } else {
    imgDimWarn.verify(srcImage)
    .then(({ xParticlesCount, yParticlesCount }) => {
      renderer.getState().setDefaultDomImage(srcImage);
      const config = Object.assign({}, menu.submittedConfig, { xParticlesCount, yParticlesCount });
      menu.applyConfig(config);
      menu.submit();
    }, () => {
      /* User canceled loading image */
      // If we don't clear, changeListeners may not fire if same image is selected again
      imgSelect.clear();
    })
    .then(() => {
      // do this both on cancel and on accept (= .finally())
      document.documentElement.classList.remove(imageLoadingClass);
    });
  }
};
srcImage.onerror = () => {
  document.documentElement.classList.remove(imageLoadingClass);
};

imgSelect.addChangeListener((url) => {
  // Prevent messed-up app states caused by multiple parallel image loads
  if (!document.documentElement.classList.contains(imageLoadingClass)) {
    srcImage.src = url;
    document.documentElement.classList.add(imageLoadingClass);
  }
});

menu.addChangeListener((config) => {
  renderer.setConfig(config);
  if (window.localStorage) {
    window.localStorage.setItem('savedConfig', JSON.stringify(config, null, 2));
  }
});
